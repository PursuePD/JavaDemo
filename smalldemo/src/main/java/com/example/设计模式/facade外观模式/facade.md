## 外观模式

### 1.概念

> - 外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
> - 其中Facade是外观角色，也叫门面角色，客户端可以调用这个角色的方法，此角色知晓子系统的所有功能和责任，将客户端的请求代理给适当的子系统对象；Subsystem是子系统角色，可以同时拥有一个或多个子系统，每一个子系统都不是一个单独的类，而是一个类的集合，子系统并不知道门面的存在。

### 2.外观模式结构图

![1564825174623](\1564832711892.png)

> - Facade：定义子系统的多个模块的对外高层接口，通常需要调用内部多个模块，从而把客户的请求代理给适当的子系统对象。
> - 模块：接受Facade对象的委派，真正实现功能，各个模块之间可能有交互。但是请注意，facade对象知道各个模块，但是各个模块不应该知道Facade对象。

### 3.外观模式的应用

> - 何时使用
>   - 客户端不需要知道系统内部的复杂联系，整个系统只提供一个“接待员”即可。
>   - 定义系统的入口。
> - 方法
>   - 客户端不与系统耦合，外观类与系统耦合.
> - 优点
>   - **松散耦合：**外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更rong'y扩展和维护。
>   - 提高了灵活性。不管系统内部如何变化，只要不影响到外观对象，任你自由活动。
>   - 提高了安全性。想让你访问子系统的哪些业务就开通哪些逻辑，不在外观上开通的方法，你就访问不到。
>   - 简单易用。
>   - 更好的划分访问的层次。
> - 缺点
>   - 不符合开不原则，修改很麻烦。
> - 使用场景
>   - 为一个复杂的模块或子系统提供一个外界访问的接口。
>   - 子系统相对独立，外界对子系统的访问只要黑箱操作即可。
>   - 预防低水平人员带来的风险扩散。
> - 应用实例
>   - 基金（用户只和基金打交道，实际操作为基金经理人与股票和其它投资品打交道）
> - **本质** ：封装交互，简化调用。

### 4.外观模式的实现

```java
/**
 * @description: 外观模式 基金类
 * @author: CuiJiaLei
 * @create: 2019-08-03 18:31
 **/
public class Fund {
    Stock1 stock1;
    Stock2 stock2;

    public Fund() {
        //todo: 这里可以用一个容器来装这些实体
        stock1 = new Stock1();
        stock2 = new Stock2();
    }
    //购买基金
    public void buyFund() {
        //todo: 这里可以根据用户的选择和类型来选择调谁的接口
        stock1.buy();
        stock2.buy();
    }
    //赎回基金
    public void sellFund() {
        //todo: 这里可以根据用户的选择和类型来选择调谁的接口
        stock1.sell();
        stock2.sell();
    }
}

```

